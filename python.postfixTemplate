.enumerate : Enumerate value
	ANY   →   enumerate($expr$)

.reversed : Reverse iterable
	ANY   →   reversed($expr$)

.list : Convert iterable to list
	ANY   →   list($expr$)$END$

.set : Convert iterable to set
	ANY   →   set($expr$)$END$

.tuple: Convert iterable to tuple
	ANY   →   tuple($expr$)$END$

.int: Convert an object to int
	ANY   →   int($expr$)$END$

.sort : Sort iterable
	ANY   →   sort($expr$)$END$

.sortk : Sort iterable with key
	ANY   →   sort($expr$, key=$key$)$END$

.sortl : Sort iterable with lambda key
	ANY   →   sort($expr$, key=lambda x: $key$)$END$

.filter : Filter iterable
	ANY   →   filter($first$, $expr$)$END$

.filterl : Filter iterable with lambda
	ANY   →   filter(lambda x: $first$, $expr$)$END$

.map : Map iterable
	ANY   →   map($first$, $expr$)$END$

.mapl : Map iterable with lambda
	ANY   →   map(lambda x: $first$, $expr$)$END$

.open : Open a path
	ANY   →   with open($expr$) as $file_name$:\
    $END$

.openm : Open a path with mode
	ANY   →   with open($expr$, mode='$mode$') as $file_name$:\
    $END$

.openp : Open a Path object
	ANY   →   with closing($expr$.open()) as $file_name$:\
    $END$

.for : Iterate through an object
	ANY   →   for $var$ in $expr$:\
    $END$

.lc : List comprehension
	ANY   →   [$first$ for $second$ in $expr$]$END$

.lcx : List comprehension with x
	ANY   →   [$first$ for x in $expr$]$END$

.lcif : List comprehension with if
	ANY   →   [$first$ for $second$ in $expr$ if $cond$]$END$
    $END$

.lcxif : List comprehension with x and if
	ANY   →   [$first$ for x in $expr$ if $cond$]$END$
    $END$

.dc : Dict comprehension
	ANY   →   {$first$:$second$ for $third$ in $expr$}$END$

.dckv : Dict comprehension with k and v
	ANY   →   {$first$:$second$ for k, v in $expr$}$END$

.dcif : Dict comprehension with if
	ANY   →   {$first$:$second$ for $third$ in $expr$ if $cond$}$END$

.dckvif : Dict comprehension with k, v and if
	ANY   →   {$first$:$second$ for k, v in $expr$ if $cond$}$END$

.sc : Set comprehension
	ANY   →   {$first$ for $second$ in $expr$}$END$

.scx : Set comprehension with x
	ANY   →   {$first$ for x in $expr$}$END$

.scif : Set comprehension with if
	ANY   →   {$first$ for $second$ in $expr$ if $cond$}$END$
    $END$

.scxif : Set comprehension with x and if
	ANY   →   {$first$ for x in $expr$ if $cond$}$END$
    $END$

.gen : Generator expression
	ANY   →   ($first$ for $second$ in $expr$)$END$
    $END$
    
.genx : Generator expression with x
	ANY   →   ($first$ for x in $expr$)$END$
    $END$
    
.genif : Generator expression with if
	ANY   →   ($first$ for $second$ in $expr$ if $cond$)$END$
    $END$
    
.genxif : Generator expression with x and if
	ANY   →   ($first$ for x in $expr$ if $cond$)$END$
    $END$

.printf: Print an object with f-string
	ANY   →   print(f'$END${$expr$}')

.try : Wrap with try except
	ANY   →   try:\
    $expr$\
except $error$ as $error_var$:\
    $END$

.tryf : Wrap with try except and finally
	ANY   →   try:\
    $expr$\
except $error$ as $error_var$:\
    $except$\
finally:\
    $END$
